---
title: "Contact Experiment Data Analysis"
output: html_notebook
---

First Step is to load the necessary package, If you dont have them just install them. For jjstatsplot you need to install it remotely.
Just remove the dash and press enter. Then Press 3 (none package to be updated). 
?group_by()

```{r}
#remotes::install_github("sbalci/jjstatsplot") #Press 3 !!!!! i.e., installing/Updating none package! 
library(jmv)
library(datasets)
library(plyr)
library(readr)
library(dataframes2xls)
library(dplyr)
library(data.table)
library(plyr)
library(ggstatsplot)
library(jjstatsplot)
library(lme4)
library(lmerTest)
library(ggplot2)
library(rstatix)
library(coin)
library(ARTool)
```



[//]: # (Reading RAW data) 

For each participant folder in rawdata, load its csv
**make sure there is no empty folder**, i.e we expect a csv file per participant folder

```{r}
directoryIndex <- list.dirs(path = "./rawdata", full.names = TRUE)

# for debugging, let's work by now with only the first case
nrParticipants <- length(directoryIndex[-1])
#nrParticipants <- 1

# let's declare a list of dataframes (a generic list)
participantsRawList <- list()

for (i in 1:nrParticipants)
{
  name <- sprintf("rawdata/%d/%d.csv",i, i)
  #print(name)
  participantsRawList[[i]] <- read.csv(name)
}

```

let's transform distances from meters to centimeters.

```{r}
# for tidyverse
if(!require(dplyr)){install.packages('dplyr')}
library(dplyr)


for (i in 1 :length(participantsRawList))
{
  participantsRawList[[i]] <-  participantsRawList[[i]] %>%
    mutate(MaxInterpenetrationCM = MaxInterpenetration * 100.0) %>%
    mutate(AverageInterpenetrationCM = AverageInterpenetration * 100.0) %>%
    mutate(AverageOffsetFromSurfaceCM = AverageOffsetFromSurface * 100.0)
}
```

Discard first X trials per interpenetration feedback condition and then create a summary
table for each participant. You need to define **nrTrialsPerBlockToRemove**.

```{r}

nrTrialsPerBlockToRemove <- 1
#trialsToRemove <- seq(from = 1, to = nrTrialsPerBlockToRemove)

participantsFilteredDF <- participantsRawList

for (i in 1 :length(participantsRawList))
{
  participantsFilteredDF[[i]] <-  participantsFilteredDF[[i]] %>%
    group_by(Block, InterpenetrationFeedback, FullyShaded) %>% # I have added here the fully shaded because we need to do a 
    slice(nrTrialsPerBlockToRemove+1:n())
  # to double check we are discarding the right rows
  #print(participantsFilteredDF[[i]]$Trial)
}

 df_ForSubsets <- bind_rows(participantsFilteredDF, .id = "ID") # This df will be used to create the subsets for 1st part and 2nd part of the experiment. 

```
  
  
```{r}  
  # create summary 
  # this time we don't care anymore grouping by "block".
  # we care now only for interpenetration feedback and shaded

experimentDF <- data.frame(
  ID=numeric(),
  InterpenetrationFeedback=character(),
  NrOfAdjustments=numeric(),
  InterpenetrationTime=numeric(),
  TrialTime=numeric(),
  FirstContactTime=numeric(),
  MaxInterpenetrationCM=numeric(),
  AverageInterpenetrationCM=numeric(),
  AverageOffsetFromSurfaceCM=numeric(),
  ReleaseReactionTime=numeric(),
  stringsAsFactors=FALSE)


 for (i in 1 :length(participantsRawList))
{
   participantSummaryEntry <- participantsFilteredDF[[i]] %>%
    group_by(Age, Gender, InterpenetrationFeedback, FullyShaded) %>%     ##### Added FullyShaded here
    summarise_at(
      vars(
        NrOfAdjustments,# maybe nr of adjustments should be treated differently
        InterpenetrationTime,
        TrialTime,
        FirstContactTime,
        MaxInterpenetrationCM,
        AverageInterpenetrationCM,
        AverageOffsetFromSurfaceCM,
        ReleaseReactionTime),
      funs(mean(., na.rm=TRUE))
      
    )
   

# add 'participant id' column for reference
  participantSummaryEntry <- participantSummaryEntry %>%
    mutate(ID = i)  

  
  experimentDF <- rbind(experimentDF, participantSummaryEntry)
}

```

Let's show distribution of dependent variables by interpenetration feedback

```{r}

# for ggplot
if(!require(ggplot2)){install.packages('ggplot2')}
library(ggplot2)

experimentElectrotactile <- experimentDF %>%
                              filter(InterpenetrationFeedback == "Electrotactile")

experimentVisual <- experimentDF %>%
                              filter(InterpenetrationFeedback == "Visual")

experimentBoth <- experimentDF %>%
                              filter(InterpenetrationFeedback == "Both")

experimentNoFeedback <- experimentDF %>%
                              filter(InterpenetrationFeedback == "NoFeedback")

binSize = 0.25# cm

ggplot(data=experimentElectrotactile, aes(AverageInterpenetrationCM)) + 
  geom_histogram(binwidth = binSize, col="white", size=.5)

ggplot(data=experimentVisual, aes(AverageInterpenetrationCM)) + 
  geom_histogram(binwidth = binSize, col="white", size=.5)

ggplot(data=experimentBoth, aes(AverageInterpenetrationCM)) + 
  geom_histogram(binwidth = binSize, col="white", size=.5)

ggplot(data=experimentNoFeedback, aes(AverageInterpenetrationCM)) + 
  geom_histogram(binwidth = binSize, col="white", size=.5)

```
Convert from meters to cm (df for subsets)

```{r}
df_ForSubsets$MaxInterpenetration <- df_ForSubsets$MaxInterpenetration * 100
df_ForSubsets$AverageInterpenetration <- df_ForSubsets$AverageInterpenetration * 100
df_ForSubsets$AverageOffsetFromSurface <- df_ForSubsets$AverageOffsetFromSurface * 100

```


Now I want to a simple name for our experiment df
```{r}

df <- experimentDF

df$MaxInterpenetration <- df$MaxInterpenetrationCM
df$AverageInterpenetration <- df$AverageInterpenetrationCM

```

Cleaning Outliers (The threshold will be 2.5 standard deviations from the mean - in both directions!)

```{r}

# We NA every entry which is beyond our threshold (We focus on the performace variables)

df$MaxInterpenetration[df$MaxInterpenetration > mean(df$MaxInterpenetration) + 2.5 * sd(df$MaxInterpenetration)] <- NA

df$AverageInterpenetration[df$AverageInterpenetration > mean(df$AverageInterpenetration) + 2.5 * sd(df$AverageInterpenetration)] <- NA

df$MaxInterpenetration[df$MaxInterpenetration < mean(df$MaxInterpenetration) - 2.5 * sd(df$MaxInterpenetration)] <- NA

df$AverageInterpenetration[df$AverageInterpenetration < mean(df$AverageInterpenetration) - 2.5 * sd(df$AverageInterpenetration)] <- NA

df_clean <- na.omit(df) #We omit the rows which have NA values !!! and we create a new dataset without outliers.

#we check again the histograms
hist(df_clean$MaxInterpenetration) 
hist(df_clean$AverageInterpenetration)
#Positively skewed!

```

We will run an Anova to see the comparisons amongst the 4 types of feedbcak for our performance variables

```{r}
jmv::anovaOneW(
  formula = MaxInterpenetration + AverageInterpenetration  ~ InterpenetrationFeedback,
  data = df_clean,
  fishers = TRUE,
  desc = TRUE,
  descPlot = TRUE,
  norm = TRUE,
  qq = TRUE,
  eqv = TRUE,
  phMethod = "gamesHowell",
  phTest = TRUE,
  phFlag = TRUE)

```
The intepretation of an ANOVA: 

1st We check the Normality (distribution of the data) ---- 

Unfortunately, the p value is below .05 for each performance variable,  which means that we dont have a normal distribution. 
Since the ANOVA is highly dependent on the variance, and our data dont have a normally distributed variance,  
that means that the results of this ANOVA are utterly unreliable and dont demonstrate the true effects between the independent variables (IVs).
The IVs in this care are the 4 types of feedback.


2nd We check also the homoscedacity of the variance (i.e., if the variance is homogeneous or not). 
This tests works as the above, i.e., we dont want a p-value below .05 ! 
In this case the variance is homogeneous 

(Homogeneity of variance (also called homoscedasticity) is used to describe a set of data that has the same variance. Visually, the data will have the same scatter on a scatter plot. If data does not have the same variance, it will show a heteroscedastic (“not the same”) scatter pattern.)

So check the scatter plots above to get it also visually


We dont need to check the results further since we have a problem with the Normality of the Variance, 
so the ANOVA cannot detect and measure the possible effects. 

As you can see the on the Games-Howell Post-Hoc Test, there is NOT any effect between the IVs for every dependent variable (DV). 



Let's try to correct the problem with the Normality of the Variance. 
The reason, as we can see above by checking the histograms, is that the distribution is very positively skewed.
We dont want any type of an intense skew (Though, always there is somewhat of skewness in the data). 

```{r}
#A common thing to resolve the positive skewness is to covert the data to logarithms 

df_clean$MaxInterpenetration <- log10(df_clean$MaxInterpenetration)

df_clean$AverageInterpenetration <- log10(df_clean$AverageInterpenetration)

# You may run the ANOVA from above, and you will see that we stll violate the Normality assumption.

```


```{r}
#Another more extreme solution for positive skewness
# For extreme cases like this one we can try also to divide 1 by our values (Re assign )

df_clean$MaxInterpenetration <- 1/df_clean$MaxInterpenetration

df_clean$AverageInterpenetration <- 1/df_clean$AverageInterpenetration

# You may run the ANOVA from above, and you will see that we stll violate the Normality assumption.

```


let's check the plots of the means to see what happens (df clean first).


```{r}

p1 <- ggstatsplot::ggbetweenstats(
  data = df_clean,
  x = "InterpenetrationFeedback",
  y = "MaxInterpenetration",
  grvar= NULL,
  ) 

p2 <- ggstatsplot::ggbetweenstats(
  data = df_clean,
  x = "InterpenetrationFeedback",
  y = "AverageInterpenetration",
  grvar= NULL,
) 

plist <- list(p1,p2)

combine_plots2(
  plotlist = plist, 
  labels = c("(Maximum)", "(Average)", "(Time)"),
  title.text = "Interpenetration Violin Plots",
  caption.text = "Note: Interpenetration distance is displayed in cm.",
  title.color = "black",
  caption.color = "black")


```


So,based on the plot, we can see that should be an effect at least between Both (combined feedback) and No Feedback.

Anyhow, we need to go for a non-parametric Repeated measures ANOVA because we cant resolve the normality issue. 

In this case, we want an equivalent of one-way ANOVA (one way = one IV, as we have in our case i.e., our IV is the Interpenetration feedback which has 4 levels i.e., the types of feedback). 

The non-parametric equivalent of one-way Repeated measure ANOVA is the Friedman's test. 


So, lets go for a Friedman's test. 

```{r}
friedman_test(MaxInterpenetration + AverageInterpenetration  ~ InterpenetrationFeedback + Shaded, data = df_clean) 
?friedman_test()


#OK we have a significant effect of the IV levels on the DV. But which one has the greatest effect?


#To see the differences between them, we do pairwist test.
#Though, because we will do multiple comparisons, we also need a post hoc test to avoid a false positive (see multiple comparisons problem: https://en.wikipedia.org/wiki/Multiple_comparisons_problem). The most parsimonious adjustment is 
# the bonferonni correction. 
pairwise.wilcox.test(df_clean$MaxInterpenetration, df_clean$InterpenetrationFeedback, p.adjust.method = "bonferroni")

pairwise.wilcox.test(df_clean$AverageInterpenetration, df_clean$InterpenetrationFeedback, p.adjust.method = "bonferroni")
```

We can see that there is an effect between Visual & NoFeedback, Both & NoFeedback, and the rest comparisons did not 
show significant differences. 

However, for non-paranetric we dont care for normality so we may even include the outliers (i.e., df dataframe)
```{r}
#Let's see the means plot for df
  p3 <- ggstatsplot::ggbetweenstats(
    data = df,
    x = "InterpenetrationFeedback",
    y = "MaxInterpenetration", 
    grvar= NULL,
  ) 

p4 <- ggstatsplot::ggbetweenstats(
  data = df,
  x = "InterpenetrationFeedback",
  y = "AverageInterpenetration",
  grvar= NULL,
) 

plist2 <- list(p3,p4)

combine_plots2(
  plotlist = plist2, 
  labels = c("(Maximum)", "(Average)"),
  title.text = "Interpenetration Violin Plots",
  caption.text = "Note: Interpenetration distance is displayed in cm.",
  title.color = "black",
  caption.color = "black")


```
OK, it very similar to the cleaned one

we may now run the non-parametric Repeated measures ANOVA with df now

```{r}

kruskal.test(MaxInterpenetration + AverageInterpenetration ~ InterpenetrationFeedback, data = df)

pairwise.wilcox.test(df$MaxInterpenetration, df$InterpenetrationFeedback, p.adjust.method = "bonferroni")

pairwise.wilcox.test(df$AverageInterpenetration, df$InterpenetrationFeedback, p.adjust.method = "bonferroni")

?pairwise.wilcox.test()

```


Now let's split our dataframe into two subtests (1st part and 2nd part of the experiment) to inspect whether there is
an effect of familirisation with electrotactile feedback, as well as a learning effect
```{r}
df_ForSubsets$ID <- df_ForSubsets$column_label

Data_1st <- subset(df_ForSubsets, df_ForSubsets$Block < 4)

Data_2nd <- subset(df_ForSubsets, df_ForSubsets$Block > 3)

Data_1st <- select(Data_1st, "ID", "Age", "Gender", "InterpenetrationFeedback", "MaxInterpenetration", "AverageInterpenetration")
Data_2nd <- select(Data_2nd, "ID", "Age", "Gender", "InterpenetrationFeedback", "MaxInterpenetration", "AverageInterpenetration")

Data_1st <- aggregate(. ~ ID + InterpenetrationFeedback + Age + Gender, Data_1st, mean)

Data_2nd <- aggregate(. ~ ID + InterpenetrationFeedback + Age + Gender, Data_2nd, mean)
```



No we wil check the same analyses (ANOVA Parametric, ANOVA non-parametric Repeated measures, Pairwise Comps) for each subset.
```{r}

# 1st Part
jmv::anovaOneW(
  formula = MaxInterpenetration + AverageInterpenetration ~ InterpenetrationFeedback,
  data = Data_1st,
  fishers = TRUE,
  desc = TRUE,
  descPlot = TRUE,
  norm = TRUE,
  qq = TRUE,
  eqv = TRUE,
  phMethod = "gamesHowell",
  phTest = TRUE,
  phFlag = TRUE)


kruskal.test(MaxInterpenetration + AverageInterpenetration ~ InterpenetrationFeedback, data = Data_1st)

pairwise.wilcox.test(Data_1st$MaxInterpenetration, Data_1st$InterpenetrationFeedback, p.adjust.method = "bonferroni")

pairwise.wilcox.test(Data_1st$AverageInterpenetration, Data_1st$InterpenetrationFeedback, p.adjust.method = "bonferroni")

par(mfrow=c(2,2))


  p5 <- ggstatsplot::ggbetweenstats(
    data = Data_1st,
    x = "InterpenetrationFeedback",
    y = "MaxInterpenetration",
    grvar= NULL,
  ) 

p6 <- ggstatsplot::ggbetweenstats(
  data = Data_1st,
  x = "InterpenetrationFeedback",
  y = "AverageInterpenetration",
  grvar= NULL,
) 

plist3 <- list(p5,p6)

combine_plots2(
  plotlist = plist3, 
  labels = c("(Maximum)", "(Average)"),
  title.text = "Interpenetration Violin Plots",
  caption.text = "Note: Interpenetration distance is displayed in cm, time in seconds",
  title.color = "black",
  caption.color = "black")


#Second Part

jmv::anovaOneW(
  formula = MaxInterpenetration + AverageInterpenetration ~ InterpenetrationFeedback,
  data = Data_2nd,
  fishers = TRUE,
  desc = TRUE,
  descPlot = TRUE,
  norm = TRUE,
  qq = TRUE,
  eqv = TRUE,
  phMethod = "gamesHowell",
  phTest = TRUE,
  phFlag = TRUE)


kruskal.test(MaxInterpenetration + AverageInterpenetration ~ InterpenetrationFeedback, data = Data_2nd)

pairwise.wilcox.test(Data_2nd$MaxInterpenetration, Data_2nd$InterpenetrationFeedback, p.adjust.method = "bonferroni")

pairwise.wilcox.test(Data_2nd$AverageInterpenetration, Data_2nd$InterpenetrationFeedback, p.adjust.method = "bonferroni")


  p7 <- ggstatsplot::ggbetweenstats(
    data = Data_2nd,
    x = "InterpenetrationFeedback",
    y = "MaxInterpenetration",
    grvar= NULL,
  ) 

p8 <- ggstatsplot::ggbetweenstats(
  data = Data_2nd,
  x = "InterpenetrationFeedback",
  y = "AverageInterpenetration",
  grvar= NULL,
) 

plist4 <- list(p7,p8)

combine_plots2(
  plotlist = plist4, 
  labels = c("(Maximum)", "(Average)"),
  title.text = "Interpenetration Violin Plots",
  caption.text = "Note: Interpenetration distance is displayed in cm, time in seconds",
  title.color = "black",
  caption.color = "black")

```





############################# Preparation of the datasets for t-tests: 1st part vs 2nd part for each type of feedback
```{r}
#Divide them to before and after
B1 <- filter(Data_1st, InterpenetrationFeedback == "Both")
B1$B1MaxInt <- select(B1, MaxInterpenetration) 
B1$B1AvInt <- select(B1, AverageInterpenetration)

El1 <-filter(Data_1st, InterpenetrationFeedback == "Electrotactile")
El1$El1Maxint <- select(El1, MaxInterpenetration) 
El1$El1AvInt  <- select(El1, AverageInterpenetration)

No1 <- filter(Data_1st, InterpenetrationFeedback == "NoFeedback")
No1$No1MaxInt <- select(No1, MaxInterpenetration) 
No1$No1AvInt <- select(No1, AverageInterpenetration)

V1 <- filter(Data_1st, InterpenetrationFeedback == "Visual")
V1$V1MaxInt <- select(V1, MaxInterpenetration) 
V1$V1AvInt <- select(V1, AverageInterpenetration)

B2 <- filter(Data_2nd, InterpenetrationFeedback == "Both")
B2$B2MaxInt <- select(B2, MaxInterpenetration) 
B2$B2AvInt <- select(B2, AverageInterpenetration)

El2 <-filter(Data_2nd, InterpenetrationFeedback == "Electrotactile")
El2$El2Maxint <- select(El2, MaxInterpenetration) 
El2$El2AvInt  <- select(El2, AverageInterpenetration)

No2 <- filter(Data_2nd, InterpenetrationFeedback == "NoFeedback")
No2$No2MaxInt <- select(No2, MaxInterpenetration) 
No2$No2AvInt <- select(No2, AverageInterpenetration)

V2 <- filter(Data_2nd, InterpenetrationFeedback == "Visual")
V2$V2MaxInt <- select(V2, MaxInterpenetration) 
V2$V2AvInt <- select(V2, AverageInterpenetration)


#Merge the new datasets  (e.g., B1 & B2) and now we have two variables for the DVs (e.g., Max Interpenetration)
#the one is for the 1st part and the other for the 2nd part

Rm1 <- merge(B1,B2, by = c("ID", "Gender", "Age"))
B_MaxInt <- Rm1  %>%
  gather(key = "part", value = "MaxInt", MaxInterpenetration.x, MaxInterpenetration.y)

B_AvInt <- Rm1  %>%
  gather(key = "part", value = "AvInt", AverageInterpenetration.x, AverageInterpenetration.y)

Rm2 <- merge(El1,El2, by = c("ID", "Gender", "Age"))
E_MaxInt <- Rm2  %>%
  gather(key = "part", value = "MaxInt", MaxInterpenetration.x, MaxInterpenetration.y)
E_AvInt <- Rm2  %>%
  gather(key = "part", value = "AvInt", AverageInterpenetration.x, AverageInterpenetration.y)

Rm3 <- merge(No1, No2, by = c("ID", "Gender", "Age"))
N_MaxInt <- Rm3  %>%
  gather(key = "part", value = "MaxInt", MaxInterpenetration.x, MaxInterpenetration.y)
N_AvInt <- Rm3  %>%
  gather(key = "part", value = "AvInt", AverageInterpenetration.x, AverageInterpenetration.y)

Rm4 <- merge(V1,V2, by = c("ID", "Gender", "Age"))
V_MaxInt <- Rm4  %>%
  gather(key = "part", value = "MaxInt", MaxInterpenetration.x, MaxInterpenetration.y)
V_AvInt <- Rm4  %>%
  gather(key = "part", value = "AvInt", AverageInterpenetration.x, AverageInterpenetration.y)

#Now we merge all together to runt the test
Rm5 <- merge(Rm1,Rm2, by = c("ID", "Gender", "Age"))


Rm6 <- merge(Rm3,Rm4, by = c("ID", "Gender", "Age"))


RM <- merge(Rm5, Rm6, by = c("ID", "Gender", "Age"))
RM <- select(RM,
             - "InterpenetrationFeedback.x.x.y",
             - "MaxInterpenetration.x.y.y",
             - "MaxInterpenetration.y.x.y",
             - "MaxInterpenetration.y.y.x",
             - "MaxInterpenetration.y.y.y",
             - "AverageInterpenetration.x.x.y",
             - "AverageInterpenetration.x.y.y",
             - "AverageInterpenetration.y.x.y",
             - "AverageInterpenetration.y.y.x",
             - "AverageInterpenetration.y.y.y"
)

RM <- select(RM,
             - "InterpenetrationFeedback.x.x.x",
             - "InterpenetrationFeedback.y.x.x",
             - "InterpenetrationFeedback.x.y.x",
             - "InterpenetrationFeedback.x.y.y", 
             - "InterpenetrationFeedback.y.x.x",
             - "InterpenetrationFeedback.y.x.y",
             - "InterpenetrationFeedback.y.y.x",
             - "InterpenetrationFeedback.y.y.y",
             - "MaxInterpenetration.x.x.x",
             - "MaxInterpenetration.y.x.x", 
             - "MaxInterpenetration.x.y.x",
             - "MaxInterpenetration.x.x.y",
             - "AverageInterpenetration.x.x.x",
             - "AverageInterpenetration.y.x.x", 
             - "AverageInterpenetration.x.y.x",
)

RM$B1Maxint <- RM$B1MaxInt$MaxInterpenetration
RM$B2Maxint <- RM$B2MaxInt$MaxInterpenetration
RM$El1Maxint <- RM$El1Maxint$MaxInterpenetration
RM$El2Maxint <- RM$El2Maxint$MaxInterpenetration
RM$V1Maxint <- RM$V1MaxInt$MaxInterpenetration
RM$V2Maxint <- RM$V2MaxInt$MaxInterpenetration
RM$No1Maxint <- RM$No1MaxInt$MaxInterpenetration
RM$No2Maxint <- RM$No2MaxInt$MaxInterpenetration

RM$B1AvInt <- RM$B1AvInt$AverageInterpenetration
RM$B2AvInt <- RM$B2AvInt$AverageInterpenetration
RM$El1AvInt <- RM$El1AvInt$AverageInterpenetration
RM$El2AvInt <- RM$El2AvInt$AverageInterpenetration
RM$V1AvInt <- RM$V1AvInt$AverageInterpenetration
RM$V2AvInt <- RM$V2AvInt$AverageInterpenetration
RM$No1AvInt <- RM$No1AvInt$AverageInterpenetration
RM$No2AvInt <- RM$No2AvInt$AverageInterpenetration



```



Now we are ready to run the T-tests 1st vs 2nd part, as wel as to calculate the effect size for each one comparison. The tested hypothesis will be that the Maximum or the Averaged interpenetration will be greater in each condition (type of feedback) in the first part than the 2n part. However, our research hypothesis is that the effect size will be greater for the electrotactile and both.
```{r}

wilcox.test(RM$B1Maxint,RM$B2Maxint, paired = TRUE, exact = TRUE, conf.int = TRUE,alternative = "greater")

stats_B_Max <- wilcox_effsize(B_MaxInt, 
               formula = MaxInt ~ part,
               paired =  TRUE, # The type of t-test is a paired
               alternative = "greater", #The direction of the hypothesis i.e., in this case A > B
               nboot = 1000 #bootstrapping 1000 samples
               )

View(stats_B_Max)

wilcox.test(RM$El1Maxint,RM$El2Maxint, paired = TRUE, exact = TRUE, conf.int = TRUE,alternative = "greater")

stats_E_Max <- wilcox_effsize(E_MaxInt, 
               formula = MaxInt ~ part,
               paired =  TRUE, # The type of t-test is a paired
               alternative = "greater", #The direction of the hypothesis i.e., in this case A > B
               nboot = 1000 #bootstrapping 1000 samples
               )
View(stats_E_Max)

wilcox.test(RM$V1Maxint, RM$V2Maxint, paired = TRUE, exact = TRUE, conf.int = TRUE,alternative = "greater")

stats_V_Max <- wilcox_effsize(V_MaxInt, 
               formula = MaxInt ~ part,
               paired =  TRUE, # The type of t-test is a paired
               alternative = "greater", #The direction of the hypothesis i.e., in this case A > B
               nboot = 1000 #bootstrapping 1000 samples
               )
View(stats_V_Max)


wilcox.test(RM$No1Maxint, RM$No2Maxint, paired = TRUE, exact = TRUE, conf.int = TRUE,alternative = "greater")
stats_N_Max <- wilcox_effsize(V_MaxInt, 
               formula = MaxInt ~ part,
               paired =  TRUE, # The type of t-test is a paired
               alternative = "greater", #The direction of the hypothesis i.e., in this case A > B
               nboot = 1000 #bootstrapping 1000 samples
               )
View(stats_N_Max)




#For Averaged 

wilcox.test(RM$B1AvInt,RM$B2AvInt, paired = TRUE, exact = TRUE, conf.int = TRUE,alternative = "greater")

wilcox.test(RM$El1AvInt,RM$El2AvInt, paired = TRUE, exact = TRUE, conf.int = TRUE,alternative = "greater")

wilcox.test(RM$V1AvInt, RM$V2AvInt, paired = TRUE, exact = TRUE, conf.int = TRUE,alternative = "greater")

wilcox.test(RM$No1AvInt, RM$No2AvInt, paired = TRUE, exact = TRUE, conf.int = TRUE,alternative = "greater")



               
wilcox_effsize(B_MaxInt, 
               formula = B_MaxInt$MaxInt ~ B_MaxInt$part,
               comparisons = list(c(B_MaxInt$B1MaxInt, B_MaxInt$B2MaxInt)),
               paired =  TRUE, # The type of t-test is a paired
               alternative = "greater", #The direction of the hypothesis i.e., in this case A > B
               nboot = 1000 #bootstrapping 1000 samples
               )

wilcox_effsize(RM, 
               formula = B1MaxInt ~ B2MaxInt, #the formula is redundant here so we just add the 1 to consider random effects  
               comparisons = list(c("RM$B1MaxInt", "RM$B2MaxInt")),
               paired =  TRUE, # The type of t-test is a paired
               alternative = "greater", #The direction of the hypothesis i.e., in this case A > B
               ci = TRUE, #provide the confidence intervals
               nboot = 1000 #bootstrapping 1000 samples
               )
```


```{r}

```



```{r}

```


